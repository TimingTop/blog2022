

想要提高系统的性能，缓存是最直接最简单的方法之一；缓存一方面可以减少数据库负载；
另一方面还可以减少相应的响应时间、节省成本。但是使用缓存也会导致数据不一致的问题。

总的来说，我们一般如何使用缓存？有几种经典的缓存使用模式


缓存使用模式

1. Cache-Aside pattern 旁路缓存模式
    适用于读请求较多的场景。读的时候，先读缓存，缓存命中的话，直接返回数据；缓存没有命中的话，就去读数据库，从数据库去除数据，放入缓存后，同时返回响应。写请求时，更新的时候，先更新数据库，然后再删除缓存。

    使用最为广泛的一种模式。应用直接去缓存中找数据，命中缓存则直接返回，如果未命中缓存，
则需要先去数据库中查询数据，并将查询到的数据存储到缓存中。在旁路缓存模式中服务端需要同时维护DB和cache，并且是以DB的结果为准。但是当未命中缓存时，才会从数据库查询最新的数据，所以这样的方式会导致缓存中的数据与数据库中的数据不一致。一般我们会给缓存中的数据设置过期时间TTL，数据过期后就会去数据库查询最新的数据。所以旁路缓存模式对缓存失效具有一定的容忍性，即使缓存集群挂掉，我们仍然可以通过直接访问数据库的方式来进行操作；另外一点是，缓存中的数据模型可以与数据库的数据模型不同。
 
    缺陷：
    首次请求数据一定不在 cache 的问题，解决方案是可以先将热点数据提请放入 cache 中。另外一点是，写操作比较频繁的话会导致cache中的数据会被频繁删除，这样会影响缓存命中率。解决方法有，一数据库和缓存数据强一致场景，更新DB的时候同样更新cache，不过我们需要加一个分布式锁来保证更新cache的时候不存在线程安全问题。二，数据库和缓存允许最终一致，短暂的数据不一致场景。更新db的同样更新cache，但是给缓存加一个比较短的过期时间，止痒的话就可以保证即使数据不一致的话影响也比较少。


2. Read-Through Cache/ Write-Throught 读写穿透
    适用于服务端把Cache视为主要数据源的场景，Cache服务分担请求线程的工作、执行DB的读写，
并发。减少应用程序的职责。读请求时，从缓存中找数据，命中则直接返回；如果读不到时，则先由Cache服务自己将从DB读到的数据写入缓存，然后再返回响应。写请求时，先查Cache，如果Cache不存在，先写入Cache，然后由Cache服务写入DB。写穿透模式每写一次Cache，缓存服务就会写一次DB，带来了额外的写延时成本，要配合读穿透一起使用，保证Cache是最新数据。

    写穿透模式与旁路缓存模式接近，区别在于，旁路缓存模式是通过应用程序来更新缓存中的数据，
而写穿透则是直接通过缓存自身来更新数据，也就是说应用和数据库之间不直接进行连接，并且，由于缓存与数据库之间没有应用程序的介入，读穿透中缓存的数据模型不能与数据库中的数据模型不同。

    缺点：
    首次请求时，数据也是一定不在cache中，然后Cache服务器就要从DB中获取数据加载到缓存的
成本。

3. Write Around
    直接写入Db，


3. Write Behind pattern 异步缓存写入
    适用于写请求较多的场景，对一致性要求低，异步缓存写入的写性能非常高，浏览量、点赞量场景。

    异步缓存写入都是由Cache服务来负责Cache和DB的读写。读写穿透模式是同步更新Cache和DB
而异步缓存写入则是只更新Cache，不直接更新DB，而是改为异步批量的方式更新DB。

    缺点：
    对数据一致性带来更大的挑战，如果Cache的数据还没异步更新DB，Cache服务挂掉，会导致数
据丢失。但是消息队列中消息的异步写入磁盘，MySql InnoDB Buffer Pool机制都是这种策略。





多级缓存策略。

除了分布式缓存，还有本地缓存。本地缓存，直接从本地内存中读取，没有网络开销。Guava cache，
Caffeine 

1. 只使用redis来做缓存，会到时很多redis的网络开销，如果有本地缓存就能减少网络请求，响应时间也会变化。
2. 如果只使用本地缓存，但是应用服务的内存是有限，并且单独为缓存去扩展应用服务器是非常不花苏。本地缓存有很大的局限性。

因此项目中，我们将热点数据放在本地缓存，作为一级缓存，将非热点数据放redis缓存，作为二级缓存，减少redis的查询压力。

读请求，首先从一级缓存中查找数据；如果没有命中，则从二级缓存中查找数据；如果还是没有命中，则就要从db中查找数据。

写请求，通过监听redis发布的消息，实现分布式集群多节点本地缓存清除从而达到数据的一致性。


接口权限校验，每次请求接口都需要根据当前登录人有哪些角色，角色有哪些权限，并且权限一般不会去更改。


客户端缓存
使用的是ReactJS的单页面应用，单页面应用中，初始页面的加载只发生一次。通过javascript等技术实现动态交互，在用户与应用程序交互时，只更新页面的部分内容，而不用重新加载整个页面。这使得单页面应用更加快速、响应迅速，并提供了更好的用户体验。
单页面应用通过动态地更新页面的部分内容，实现与用户的交互和数据显示，避免了传统多页面应用的页面应用和重新加载

提供了更好的用户体验、快速影响和良好的性能。
缺点：
    首次加载时间较长，由于单页应用一开始需要加载完所有的资料，因此初始加载可能会比较慢。
    内存占用较大。

解决方案：
    代码分割，
    资源懒加载    
    页面预取，提前预取下一个页面所需要的资源


淘汰策略

random
FIFO
LRU
LFU
